/*

Derived from the Create Midifile  example for  libJDKSmidi C++ MIDI Library

Copyright (C) 2010 V.R.Madgazin
www.vmgames.com
vrm@vmgames.com

This program is free software; you can redistribute it and/or
modify it under the terms of the GNU General Public License
as published by the Free Software Foundation; either version 2
of the License, or (at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program;
if not, write to the Free Software Foundation, Inc.,
51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.

*/

#ifdef WIN32
#include <windows.h>
#endif

#include<fstream>
#include "jdksmidi/world.h"
#include "jdksmidi/track.h"
#include "jdksmidi/multitrack.h"
#include "jdksmidi/filereadmultitrack.h"
#include "jdksmidi/fileread.h"
#include "jdksmidi/fileshow.h"
#include "jdksmidi/filewritemultitrack.h"
//#include "add_notes_to_midi.cpp"
using namespace jdksmidi;

#include <iostream>
#include <vector>
#include <string>
#include<list>
using namespace std;

void add_notes_to_midi(vector<MIDIClockTime>* &note_array, MIDITimedBigMessage &m, MIDIMultiTrack &tracks, int &trk, MIDIClockTime &t, unsigned char &chan, unsigned char &note, unsigned char &velocity, unsigned char &ctrl, unsigned char &val, bool quartet_mode) {
	// go through all the notes
	MIDIClockTime on, off; // used to get the on/off times of each note from the input vector
	int channel = 0; // used if quartet_mode is enabled to switch to other channels for different ranges of notes
	for (int note_id = 0; note_id < 88; note_id++) { // loop through all the note pitches
		// if quartet_mode
		if (quartet_mode) {
			if (note_id == 22) channel = 1;
			if (note_id == 44) channel = 2;
			if (note_id == 66) channel = 3;
		};
		for (unsigned int i = 1; i < note_array[note_id].size(); i += 2) { // loop through all the pairs of on/off times
			on = note_array[note_id][i - 1]; // get the on time
			off = note_array[note_id][i]; // get the off time

			m.SetTime(on); // go to the on time
			m.SetNoteOn(chan = channel, note = note_id, velocity = 100); // turn the note on
			tracks.GetTrack(trk)->PutEvent(m); // put the on event

			m.SetTime(off); // go to the off time 
			m.SetNoteOff(chan = channel, note = note_id, velocity = 100); // turn the note off
			tracks.GetTrack(trk)->PutEvent(m); // put the off event
		}
		// add a pause at the end of the track
		m.SetTime(off + 100);
		m.SetNoteOn(chan = channel, note = 0, velocity = 0);
		tracks.GetTrack(trk)->PutEvent(m);
	}
}

int create_midi_file(vector<MIDIClockTime>* note_array, string Fname, bool quartet_mode, vector<int> instrument) {
	int return_code = -1;

	MIDITimedBigMessage m; // the object for individual midi events
	unsigned char chan, // internal midi channel number 0...15 (named 1...16)
		note, velocity, ctrl, val;

	MIDIClockTime t; // time in midi ticks
	int clks_per_beat = 30; // number of ticks in crotchet (1...32767) -- frames / sec in video
	int num_tracks = 2; // tracks 0 and 1

	MIDIMultiTrack tracks(num_tracks);  // the object which will hold all the tracks
	tracks.SetClksPerBeat(clks_per_beat);
	int trk; // track number, 0 or 1

	t = 0;
	m.SetTime(t);

	// track 0 is used for tempo and time signature info, and some other stuff

	trk = 0;

	m.SetTimeSig(4, 2); // measure 4/4 (default values for time signature)
	tracks.GetTrack(trk)->PutEvent(m);

	int tempo = 1000000; // set tempo to 1 000 000 usec = 1 sec in crotchet
						 // with value of clks_per_beat (100) result 10 msec in 1 midi tick
						 // If no tempo is defined, 120 beats per minute is assumed.

	m.SetTempo(tempo);
	tracks.GetTrack(trk)->PutEvent(m);

	// META_TRACK_NAME text in track 0 music notation software like Sibelius uses as headline of the music
	tracks.GetTrack(trk)->PutTextEvent(t, META_TRACK_NAME, "MIDI file generated by Scroll Reader by Measured Solutions");

	// create cannal midi events and add them to a track 1

	trk = 1;

	// META_TRACK_NAME text in tracks >= 1 Sibelius uses as instrument name (left of staves)
	tracks.GetTrack(trk)->PutTextEvent(t, META_TRACK_NAME, "Piano");

	// set pan on chan 0 to center 
	m.SetControlChange(chan = 0, ctrl = 0xA, val = 64); // channel 0 panorama = 0 at the center
	tracks.GetTrack(trk)->PutEvent(m);

	// if quartet mode, set 4 instruments
	if (quartet_mode) {
		for (int i = 0; i < 4; i++) {
			m.SetProgramChange(chan = i, val = instrument[i]);
			tracks.GetTrack(trk)->PutEvent(m);
		}
	}
	else {
		m.SetProgramChange(chan = 0, val = 0); // chan 0 instrument 0 - Piano
		tracks.GetTrack(trk)->PutEvent(m);
	}

	add_notes_to_midi(note_array, m, tracks, trk, t, chan, note, velocity, ctrl, val, quartet_mode);

	// if events in any track recorded not in order of the growth of time,
	tracks.SortEventsOrder(); // it is necessary to do this before write step

	// to write the multi track object out, you need to create an output stream for the output filename
	const char *outfile_name = Fname.c_str();
	MIDIFileWriteStreamFileName out_stream(outfile_name);

	// then output the stream like my example does, except setting num_tracks to match your data
	if (out_stream.IsValid())
	{
		// the object which takes the midi tracks and writes the midifile to the output stream
		MIDIFileWriteMultiTrack writer(&tracks, &out_stream);

		// write the output file
		if (writer.Write(num_tracks))
		{
			//cout << "\nOK writing file " << outfile_name << endl;
			return_code = 0;
		}
		else
		{
			//cerr << "\nError writing file " << outfile_name << endl;
		}
	}
	else
	{
		//cerr << "\nError opening file " << outfile_name << endl;
	}

	return return_code;
}

// outputs log file for testing purposes (can be removed when program is completed)
void logMidi(vector<MIDIClockTime> *note_array)
{
	ofstream of("MIDIlog.txt");
	for (int i = 0; i < 88; i++)
	{
		of << i << ": ";
		for (int j = 0; j < note_array[i].size(); j++)
		{
			of << note_array[i][j];
			if (j % 2 == 0)
			{
				of << '-';
			}
			else
			{
				of << '\t';
			}
		}
		of << endl;
	}
}

int main(int argc, char* argv[])
{
	if (argc < 4)
	{
		return -1;
	}
	string Fname = argv[1], Dname = argv[2];
	bool quartet_mode = stoi(argv[3]); // determines whether in quartet mode
	// if in quartet mode, must have additional 4 arguments to specify the instruments
	vector<int> instrument;
	if (quartet_mode) {
		for (int i = 4; i < 8; i++) {
			instrument.push_back(stoi(argv[i]));
		}
	}

	vector<MIDIClockTime> NoteTimes[88];
	
	ifstream Infile(Fname);
	string buf; // used to read in each line of the output of the CV code

	bool PastVals[88];
	for (int i = 0; i < 88; i++)
	{
		PastVals[i] = false;
		//NoteCount[i] = 0;
	}

	int FrameNum = 1;
	

	// this loop takes in the output of the CV code and translates it into a format readable by the MIDI code.
	while (getline(Infile, buf))
	{
		int CurrNote = 2;
		for (int i = 0; i < buf.length(); i++)
		{
			char tmpVal = buf[i];
			if (CurrNote < 88)
			{
				if (tmpVal == '0')
				{
					if (PastVals[CurrNote])
					{
						NoteTimes[CurrNote].push_back(FrameNum);
						PastVals[CurrNote] = false;
					}
					CurrNote++;
				}
				else if (tmpVal == '1')
				{
					if (!PastVals[CurrNote])
					{
						NoteTimes[CurrNote].push_back(FrameNum);
						PastVals[CurrNote] = true;
					}
					CurrNote++;
				}
			}
		}
		FrameNum++;
	}
	return create_midi_file(NoteTimes, Dname, quartet_mode, instrument);

}



